<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>递归</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

</head>
<body>
    
</body>
<script>
console.log('这里是函数表达式的实验')
/*
有两种创建函数的方式，函数声明和函数表达式。
函数表达式能创建匿名函数，又叫拉姆达函数，为什么叫匿名函数：因为一般函数可以通过函数名.name来调用函数名，但是匿名函数的name属性是空字符串
下面是这两种方式的demo
*/
test1func1();//函数声明可以使用函数提升
function test1func1(arg0,arg1,rag2){
         console.log('使用function关键字来声明函数从而创建函数')
}
//test1func2();函数表达式不能的函数提升
var test1func2=function(arg0,rag1,rag2){
         console.log('将函数传递给变量的方式创建匿名函数是函数表达式方法的一种')
}
test1func2();

if(true){
    function sayHi(){
        console.log('hi')
    }
}else{
    function saybye(){
        console.log('bye')
    }
}
/*
上面这个是无效语法，切勿使用；应使用以下语法
*/
if(true){
    sayHi=function(){
        console.log('hi')
    }
}else{
    saybye=function(){
        console.log('bye')
    }
}
console.log('这里是递归的实验')
function test2func1(num){
    if(num<=1){
        return 1
    }else{
        return num*test2func1(num-1)
    }
}
console.log(test2func1(3))//6
var test2func2=test2func1;
test2func1=null;
try{console.log(console.log(test2func2(4)))}
catch(e){
    console.log(e)
}
/*
这个问题归根到底是耦合的问题；
为了解决问题并且降低耦合，可以使用下面两种方法来优化递归
*/
function test2func3(num){
        if(num<=1){
            return 1
        }else{
            return num*arguments.callee(num-1)
        }
}
console.log(test2func3(3))
var test2func4=test2func3;
test2func3=null;
console.log(test2func4(3))
//由于不能在严格模式中使用arguments.callee;可以采用下面这种方法替代
var test2func6=(function test2func5(num){
    if(num<=1){
        return 1
    }else{
        return num*test2func5(num-1)
    }
})
console.log(test2func6(4))//24
test2func5=null
console.log(test2func6(4))//24
/*
由此可见，将函数名赋值给另一个变量和直接将函数本身赋值给变量，是不一样的
*/








</script>
</html>
